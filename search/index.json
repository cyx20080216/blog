[{"categories":["算法"],"contents":"不知道为什么，我对着百度百科看，感觉找到的 Miller-Rabin 算法代码都是错的，便自己对着百度百科写了一个，分享出来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  #include\u0026lt;stdlib.h\u0026gt;int qPower(const int \u0026amp;a,const int \u0026amp;b,const int \u0026amp;m) { if(b==0) return 1; else if(b%2==0) { int tmp=qPower(a,b/2,m); return tmp*tmp%m; } else { int tmp=qPower(a,b/2,m); return tmp*tmp%m*a%m; } } inline bool MillerRabin(const int \u0026amp;n,const int \u0026amp;testTime=8) { if(n==0||n==1) return 0; if(n==2) return 1; int d=n-1; int s=0; while(d%2==0) { d/=2; s++; } for(int i=1;i\u0026lt;=testTime;i++) { int a=rand()%(n-2)+2; bool flag=0; int tmp=qPower(a,d,n); for(int r=0;r\u0026lt;s;r++) { if(tmp==1||qPower(a,(1\u0026lt;\u0026lt;r)*d,n)==n-1) { flag=1; break; } } if(!flag) return 0; } return 1; }   ","permalink":"https://cyx20080216.github.io/blog/post/miller-rabin/","tags":["算法"],"title":"Miller-Rabin素性测试"},{"categories":["题解"],"contents":"题目分析 读完题后，很容易就能看出来，这道题的核心是求两直线交点\n在这之前，我们要先算出这两条直线\n显然，这两条直线是给定的两座灯塔与船的连线（废话），可惜我们不知道船的位置\n我们虽然不知道船的具体位置，但是题目给了我们足以算出船相对与灯塔的方向的信息。所以，我们可以在这个方向或是反方向上取任意一点，因为同一直线上取任意两点计算得到的直线都是原直线\n具体步骤如下 这里以灯塔1为例\n我们用斜截式 $y=ax+b$ 表示该直线\n用 $x_{Light}$ 和 $y_{Light}$ 表示灯塔1的坐标\n用 $\\theta_{Boat}$ 表示船的航向\n用 $\\theta_{BoatToLight}$ 分别表示以船的航向为 $0^{\\circ}$ 下的灯塔相对于船的方向\n用 $\\theta_{LightToBoat}$ 分别表示的船相对于灯塔的方向\n用 $x_{FrontOfLight}$ 和 $y_{FrontOfLight}$ 表示位于灯塔1 $\\theta_{LightToBoat}$ 方向1单位长度的点的坐标\n画画图就可以轻易推出 $\\theta_{LightToBoat}=\\theta_{Boat}+\\theta_{BoatToLight}+180^{\\circ}$\n利用 $\\theta_{LightToBoat}$ 我们又可以求出 $x_{FrontOfLight}=x_{Light}+sin\\theta_{LightToBoat}$ 和 $y_{FrontOfLight}=y_{Light}+cos\\theta_{LightToBoat}$\n注：这里其实跟极坐标系差不多，只不过方向不一样\n所以， $a=\\frac{y_{Light}-y_{FrontOfLight}}{x_{Light}-x_{FrontOfLight}}$ $b=y_{Light}-ax_{Light}$\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  #include\u0026lt;bits/stdc++.h\u0026gt;#define Pi 3.1415926535897932384626 using namespace std; struct Point { double x,y; Point(const double \u0026amp;x=0.0,const double \u0026amp;y=0.0): x(x), y(y) { } }; struct Line { double a,b; Line(const double \u0026amp;a=0.0,const double \u0026amp;b=0.0): a(a), b(b) { } }; inline Line twoPointToLine(const Point \u0026amp;a,const Point \u0026amp;b) { return Line((a.y-b.y)/(a.x-b.x),a.y-(a.y-b.y)/(a.x-b.x)*a.x); } inline Point twoLineToPoint(const Line \u0026amp;a,const Line \u0026amp;b) { return Point(-(a.b-b.b)/(a.a-b.a),-a.a*(a.b-b.b)/(a.a-b.a)+a.b); } Point light1,light2; double boatFOV; double light1FOV,light2FOV; inline void init() { int n; map\u0026lt;string,Point\u0026gt; light; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i=1;i\u0026lt;=n;i++) { string lightName; Point point; cin\u0026gt;\u0026gt;lightName; scanf(\u0026#34;%lf %lf\u0026#34;,\u0026amp;point.x,\u0026amp;point.y); light.insert(make_pair(lightName,point)); } scanf(\u0026#34;%lf\u0026#34;,\u0026amp;boatFOV); string lightName; cin\u0026gt;\u0026gt;lightName; light1=light.at(lightName); scanf(\u0026#34;%lf\u0026#34;,\u0026amp;light1FOV); cin\u0026gt;\u0026gt;lightName; light2=light.at(lightName); scanf(\u0026#34;%lf\u0026#34;,\u0026amp;light2FOV); } inline void solve() { Point frontOfLight1(light1.x+sin((boatFOV+light1FOV+180)*Pi/180.0),light1.y+cos((boatFOV+light1FOV+180)*Pi/180.0)); Point frontOfLight2(light2.x+sin((boatFOV+light2FOV+180)*Pi/180.0),light2.y+cos((boatFOV+light2FOV+180)*Pi/180.0)); Line light1ToBoat(twoPointToLine(light1,frontOfLight1)); Line light2ToBoat(twoPointToLine(light2,frontOfLight2)); if(light1ToBoat.a!=light2ToBoat.a) { Point boat(twoLineToPoint(light1ToBoat,light2ToBoat)); printf(\u0026#34;%.2lf %.2lf\\n\u0026#34;,boat.x,boat.y); } else printf(\u0026#34;NO ANSWER\\n\u0026#34;); } int main() { init(); solve(); return 0; }   ","permalink":"https://cyx20080216.github.io/blog/post/solution-p2013/","tags":["题解","洛谷"],"title":"题解 P2013 无线电测向"},{"categories":["题解"],"contents":"这道题应该使用动态规划 但是我们一看题目就会发现，这样做时间复杂度会达到$O(n^4)$\n于是大佬们就开始用线段树等来进行优化\n可是真的需要优化吗?\n让我们算一算：\n$R,C\u0026lt;=100$\n$O(n^4)$的复杂度会使循环体被运行$10^8$次，约$530$毫秒，而且实际运算时时间会更短\n所以，这道题不需要优化\nCode:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  #include\u0026lt;bits/stdc++.h\u0026gt;using namespace std; template\u0026lt;typename type\u0026gt; inline void read(type \u0026amp; num) { num=0; bool flag=0; char ch=getchar(); while(!(ch\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;9\u0026#39;)) flag=(ch==\u0026#39;-\u0026#39;),ch=getchar(); while(ch\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;9\u0026#39;) num=(num\u0026lt;\u0026lt;1)+(num\u0026lt;\u0026lt;3)+(ch^\u0026#39;0\u0026#39;),ch=getchar(); num=(flag?-num:num); } template\u0026lt;typename type\u0026gt; inline void write(type num) { if(num==0) { putchar(\u0026#39;0\u0026#39;); return; } char sta[30]; short top=-1; if(num\u0026lt;0) putchar(\u0026#39;-\u0026#39;); while(num!=0) sta[++top]=(char)(num%10\u0026lt;0?-(num%10):num%10),num/=10; while(top\u0026gt;=0) putchar(sta[top]+\u0026#39;0\u0026#39;),top--; } #define M 1000000007 int r,c,k; int maps[101][101],f[101][101]; inline void dp() { f[1][1]=1; for(int i=1;i\u0026lt;=r;i++) { for(int j=1;j\u0026lt;=c;j++) { if(i==1\u0026amp;\u0026amp;j==1) continue; for(int k=1;k\u0026lt;i;k++) { for(int l=1;l\u0026lt;j;l++) if(maps[i][j]!=maps[k][l]) f[i][j]=(f[i][j]+f[k][l])%M; } } } } int main() { read(r),read(c),read(k); for(int i=1;i\u0026lt;=r;i++) { for(int j=1;j\u0026lt;=c;j++) read(maps[i][j]); } dp(); write(f[r][c]); return 0; }   ","permalink":"https://cyx20080216.github.io/blog/post/solution-p4825/","tags":["题解","洛谷"],"title":"题解 P4825 【[USACO15FEB]Cow Hopscotch S】"},{"categories":null,"contents":"这是一名OIer的个人博客。\n平常会发一些题解，还有踩坑心得。\n","permalink":"https://cyx20080216.github.io/blog/abaut/","tags":null,"title":"关于"},{"categories":null,"contents":"","permalink":"https://cyx20080216.github.io/blog/search/","tags":null,"title":"🔍"}]