[{"categories":["é¢˜è§£"],"contents":"é¢˜ç›®åˆ†æ è¯»å®Œé¢˜åï¼Œå¾ˆå®¹æ˜“å°±èƒ½çœ‹å‡ºæ¥ï¼Œè¿™é“é¢˜çš„æ ¸å¿ƒæ˜¯æ±‚ä¸¤ç›´çº¿äº¤ç‚¹\nåœ¨è¿™ä¹‹å‰ï¼Œæˆ‘ä»¬è¦å…ˆç®—å‡ºè¿™ä¸¤æ¡ç›´çº¿\næ˜¾ç„¶ï¼Œè¿™ä¸¤æ¡ç›´çº¿æ˜¯ç»™å®šçš„ä¸¤åº§ç¯å¡”ä¸èˆ¹çš„è¿çº¿ï¼ˆåºŸè¯ï¼‰ï¼Œå¯æƒœæˆ‘ä»¬ä¸çŸ¥é“èˆ¹çš„ä½ç½®\næˆ‘ä»¬è™½ç„¶ä¸çŸ¥é“èˆ¹çš„å…·ä½“ä½ç½®ï¼Œä½†æ˜¯é¢˜ç›®ç»™äº†æˆ‘ä»¬è¶³ä»¥ç®—å‡ºèˆ¹ç›¸å¯¹ä¸ç¯å¡”çš„æ–¹å‘çš„ä¿¡æ¯ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è¿™ä¸ªæ–¹å‘æˆ–æ˜¯åæ–¹å‘ä¸Šå–ä»»æ„ä¸€ç‚¹ï¼Œå› ä¸ºåŒä¸€ç›´çº¿ä¸Šå–ä»»æ„ä¸¤ç‚¹è®¡ç®—å¾—åˆ°çš„ç›´çº¿éƒ½æ˜¯åŸç›´çº¿\nå…·ä½“æ­¥éª¤å¦‚ä¸‹ è¿™é‡Œä»¥ç¯å¡”1ä¸ºä¾‹\næˆ‘ä»¬ç”¨æ–œæˆªå¼ $y=ax+b$ è¡¨ç¤ºè¯¥ç›´çº¿\nç”¨ $x_{Light}$ å’Œ $y_{Light}$ è¡¨ç¤ºç¯å¡”1çš„åæ ‡\nç”¨ $\\theta_{Boat}$ è¡¨ç¤ºèˆ¹çš„èˆªå‘\nç”¨ $\\theta_{BoatToLight}$ åˆ†åˆ«è¡¨ç¤ºä»¥èˆ¹çš„èˆªå‘ä¸º $0^{\\circ}$ ä¸‹çš„ç¯å¡”ç›¸å¯¹äºèˆ¹çš„æ–¹å‘\nç”¨ $\\theta_{LightToBoat}$ åˆ†åˆ«è¡¨ç¤ºçš„èˆ¹ç›¸å¯¹äºç¯å¡”çš„æ–¹å‘\nç”¨ $x_{FrontOfLight}$ å’Œ $y_{FrontOfLight}$ è¡¨ç¤ºä½äºç¯å¡”1 $\\theta_{LightToBoat}$ æ–¹å‘1å•ä½é•¿åº¦çš„ç‚¹çš„åæ ‡\nç”»ç”»å›¾å°±å¯ä»¥è½»æ˜“æ¨å‡º $\\theta_{LightToBoat}=\\theta_{Boat}+\\theta_{BoatToLight}+180^{\\circ}$\nåˆ©ç”¨ $\\theta_{LightToBoat}$ æˆ‘ä»¬åˆå¯ä»¥æ±‚å‡º $x_{FrontOfLight}=x_{Light}+sin\\theta_{LightToBoat}$ å’Œ $y_{FrontOfLight}=y_{Light}+cos\\theta_{LightToBoat}$\næ³¨ï¼šè¿™é‡Œå…¶å®è·Ÿæåæ ‡ç³»å·®ä¸å¤šï¼Œåªä¸è¿‡æ–¹å‘ä¸ä¸€æ ·\næ‰€ä»¥ï¼Œ $a=\\frac{y_{Light}-y_{FrontOfLight}}{x_{Light}-x_{FrontOfLight}}$ $b=y_{Light}-ax_{Light}$\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  #include\u0026lt;bits/stdc++.h\u0026gt;#define Pi 3.1415926535897932384626 using namespace std; struct Point { double x,y; Point(const double \u0026amp;x=0.0,const double \u0026amp;y=0.0): x(x), y(y) { } }; struct Line { double a,b; Line(const double \u0026amp;a=0.0,const double \u0026amp;b=0.0): a(a), b(b) { } }; inline Line twoPointToLine(const Point \u0026amp;a,const Point \u0026amp;b) { return Line((a.y-b.y)/(a.x-b.x),a.y-(a.y-b.y)/(a.x-b.x)*a.x); } inline Point twoLineToPoint(const Line \u0026amp;a,const Line \u0026amp;b) { return Point(-(a.b-b.b)/(a.a-b.a),-a.a*(a.b-b.b)/(a.a-b.a)+a.b); } Point light1,light2; double boatFOV; double light1FOV,light2FOV; inline void init() { int n; map\u0026lt;string,Point\u0026gt; light; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i=1;i\u0026lt;=n;i++) { string lightName; Point point; cin\u0026gt;\u0026gt;lightName; scanf(\u0026#34;%lf %lf\u0026#34;,\u0026amp;point.x,\u0026amp;point.y); light.insert(make_pair(lightName,point)); } scanf(\u0026#34;%lf\u0026#34;,\u0026amp;boatFOV); string lightName; cin\u0026gt;\u0026gt;lightName; light1=light.at(lightName); scanf(\u0026#34;%lf\u0026#34;,\u0026amp;light1FOV); cin\u0026gt;\u0026gt;lightName; light2=light.at(lightName); scanf(\u0026#34;%lf\u0026#34;,\u0026amp;light2FOV); } inline void solve() { Point frontOfLight1(light1.x+sin((boatFOV+light1FOV+180)*Pi/180.0),light1.y+cos((boatFOV+light1FOV+180)*Pi/180.0)); Point frontOfLight2(light2.x+sin((boatFOV+light2FOV+180)*Pi/180.0),light2.y+cos((boatFOV+light2FOV+180)*Pi/180.0)); Line light1ToBoat(twoPointToLine(light1,frontOfLight1)); Line light2ToBoat(twoPointToLine(light2,frontOfLight2)); if(light1ToBoat.a!=light2ToBoat.a) { Point boat(twoLineToPoint(light1ToBoat,light2ToBoat)); printf(\u0026#34;%.2lf %.2lf\\n\u0026#34;,boat.x,boat.y); } else printf(\u0026#34;NO ANSWER\\n\u0026#34;); } int main() { init(); solve(); return 0; }   ","permalink":"https://cyx20080216.github.io/blog/post/solution-p2013/","tags":["é¢˜è§£","æ´›è°·"],"title":"é¢˜è§£ P2013 æ— çº¿ç”µæµ‹å‘"},{"categories":["é¢˜è§£"],"contents":"è¿™é“é¢˜åº”è¯¥ä½¿ç”¨åŠ¨æ€è§„åˆ’ ä½†æ˜¯æˆ‘ä»¬ä¸€çœ‹é¢˜ç›®å°±ä¼šå‘ç°ï¼Œè¿™æ ·åšæ—¶é—´å¤æ‚åº¦ä¼šè¾¾åˆ°$O(n^4)$\näºæ˜¯å¤§ä½¬ä»¬å°±å¼€å§‹ç”¨çº¿æ®µæ ‘ç­‰æ¥è¿›è¡Œä¼˜åŒ–\nå¯æ˜¯çœŸçš„éœ€è¦ä¼˜åŒ–å—?\nè®©æˆ‘ä»¬ç®—ä¸€ç®—ï¼š\n$R,C\u0026lt;=100$\n$O(n^4)$çš„å¤æ‚åº¦ä¼šä½¿å¾ªç¯ä½“è¢«è¿è¡Œ$10^8$æ¬¡ï¼Œçº¦$530$æ¯«ç§’ï¼Œè€Œä¸”å®é™…è¿ç®—æ—¶æ—¶é—´ä¼šæ›´çŸ­\næ‰€ä»¥ï¼Œè¿™é“é¢˜ä¸éœ€è¦ä¼˜åŒ–\nCode:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  #include\u0026lt;bits/stdc++.h\u0026gt;using namespace std; template\u0026lt;typename type\u0026gt; inline void read(type \u0026amp; num) { num=0; bool flag=0; char ch=getchar(); while(!(ch\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;9\u0026#39;)) flag=(ch==\u0026#39;-\u0026#39;),ch=getchar(); while(ch\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;9\u0026#39;) num=(num\u0026lt;\u0026lt;1)+(num\u0026lt;\u0026lt;3)+(ch^\u0026#39;0\u0026#39;),ch=getchar(); num=(flag?-num:num); } template\u0026lt;typename type\u0026gt; inline void write(type num) { if(num==0) { putchar(\u0026#39;0\u0026#39;); return; } char sta[30]; short top=-1; if(num\u0026lt;0) putchar(\u0026#39;-\u0026#39;); while(num!=0) sta[++top]=(char)(num%10\u0026lt;0?-(num%10):num%10),num/=10; while(top\u0026gt;=0) putchar(sta[top]+\u0026#39;0\u0026#39;),top--; } #define M 1000000007 int r,c,k; int maps[101][101],f[101][101]; inline void dp() { f[1][1]=1; for(int i=1;i\u0026lt;=r;i++) { for(int j=1;j\u0026lt;=c;j++) { if(i==1\u0026amp;\u0026amp;j==1) continue; for(int k=1;k\u0026lt;i;k++) { for(int l=1;l\u0026lt;j;l++) if(maps[i][j]!=maps[k][l]) f[i][j]=(f[i][j]+f[k][l])%M; } } } } int main() { read(r),read(c),read(k); for(int i=1;i\u0026lt;=r;i++) { for(int j=1;j\u0026lt;=c;j++) read(maps[i][j]); } dp(); write(f[r][c]); return 0; }   ","permalink":"https://cyx20080216.github.io/blog/post/solution-p4825/","tags":["é¢˜è§£","æ´›è°·"],"title":"é¢˜è§£ P4825 ã€[USACO15FEB]Cow Hopscotch Sã€‘"},{"categories":null,"contents":"è¿™æ˜¯ä¸€åOIerçš„ä¸ªäººåšå®¢ã€‚\nå¹³å¸¸ä¼šå‘ä¸€äº›é¢˜è§£ï¼Œè¿˜æœ‰è¸©å‘å¿ƒå¾—ã€‚\n","permalink":"https://cyx20080216.github.io/blog/abaut/","tags":null,"title":"å…³äº"},{"categories":null,"contents":"","permalink":"https://cyx20080216.github.io/blog/search/","tags":null,"title":"ğŸ”"}]